diff --git a/rmw_cyclonedds_cpp/src/rmw_node.cpp b/rmw_cyclonedds_cpp/src/rmw_node.cpp
index b418949..648d4ed 100644
--- a/rmw_cyclonedds_cpp/src/rmw_node.cpp
+++ b/rmw_cyclonedds_cpp/src/rmw_node.cpp
@@ -77,6 +77,8 @@
 #include "serdata.hpp"
 #include "demangle.hpp"
 
+#include <ros2profiling/profiling.h>
+
 using namespace std::literals::chrono_literals;
 
 /* Security must be enabled when compiling and requires cyclone to support QOS property lists */
@@ -316,6 +318,7 @@ struct CddsSubscription : CddsEntity
 {
   rmw_gid_t gid;
   dds_entity_t rdcondh;
+  uint64_t ts_ondataavailable;
 };
 
 struct client_service_id_t
@@ -1431,11 +1434,13 @@ extern "C" rmw_ret_t rmw_publish(
   const rmw_publisher_t * publisher, const void * ros_message,
   rmw_publisher_allocation_t * allocation)
 {
+  store_profile(publisher->topic_name, const_cast<void*>(ros_message), PROFIDX_PUB_RMW_PUBLISH, "rmw_publish", NULL);
   static_cast<void>(allocation);    // unused
   RET_WRONG_IMPLID(publisher);
   RET_NULL(ros_message);
   auto pub = static_cast<CddsPublisher *>(publisher->data);
   assert(pub);
+  store_profile(publisher->topic_name, const_cast<void*>(ros_message), PROFIDX_PUB_DDS_WRITE, "dds_write", NULL);
   if (dds_write(pub->enth, ros_message) >= 0) {
     return RMW_RET_OK;
   } else {
@@ -2243,7 +2248,9 @@ static rmw_ret_t rmw_take_int(
   CddsSubscription * sub = static_cast<CddsSubscription *>(subscription->data);
   RET_NULL(sub);
   dds_sample_info_t info;
+  uint64_t ts_enter = get_timestamp();
   while (dds_take(sub->enth, &ros_message, &info, 1, 1) == 1) {
+    uint64_t ts_leave = get_timestamp();
     if (info.valid_data) {
       *taken = true;
       if (message_info) {
@@ -2256,6 +2263,9 @@ static rmw_ret_t rmw_take_int(
         message_info->source_timestamp = info.source_timestamp;
         // TODO(iluetkeb) add received timestamp, when implemented by Cyclone
         message_info->received_timestamp = 0;
+	store_profile(subscription->topic_name, ros_message, PROFIDX_SUB_DDS_TAKE_ENTER, "dds_take_enter", &ts_enter);
+	store_profile(subscription->topic_name, ros_message, PROFIDX_SUB_DDS_TAKE_LEAVE, "dds_take_leave", &ts_leave);
+	store_profile(subscription->topic_name, ros_message, PROFIDX_SUB_DDS_ONDATA, "dds_ondata", &sub->ts_ondataavailable);
       }
 #if REPORT_LATE_MESSAGES > 0
       dds_time_t tnow = dds_time();
@@ -2408,7 +2418,11 @@ extern "C" rmw_ret_t rmw_take_with_info(
   rmw_subscription_allocation_t * allocation)
 {
   static_cast<void>(allocation);
-  return rmw_take_int(subscription, ros_message, taken, message_info);
+  uint64_t ts_enter = get_timestamp();
+  auto result = rmw_take_int(subscription, ros_message, taken, message_info);
+  store_profile(subscription->topic_name, ros_message, PROFIDX_SUB_RMW_TAKE_ENTER, "take_enter", &ts_enter);
+  store_profile(subscription->topic_name, ros_message, PROFIDX_SUB_RMW_TAKE_LEAVE, "take_leave", NULL);
+  return result;
 }
 
 extern "C" rmw_ret_t rmw_take_sequence(
@@ -3005,6 +3019,7 @@ extern "C" rmw_ret_t rmw_wait(
   const dds_return_t ntrig = dds_waitset_wait(
     ws->waitseth, ws->trigs.data(),
     ws->trigs.size(), timeout);
+  uint64_t ts_ondata = get_timestamp();
   ws->trigs.resize(ntrig);
   std::sort(ws->trigs.begin(), ws->trigs.end());
   ws->trigs.push_back((dds_attach_t) -1);
@@ -3027,7 +3042,7 @@ extern "C" rmw_ret_t rmw_wait(
       } \
     } \
 } while (0)
-    DETACH(CddsSubscription, subs, subscriber, rdcondh, (void) x);
+    DETACH(CddsSubscription, subs, subscriber, rdcondh, x->ts_ondataavailable=ts_ondata );
     DETACH(
       CddsGuardCondition, gcs, guard_condition, gcondh,
       dds_take_guardcondition(x->gcondh, &dummy));
